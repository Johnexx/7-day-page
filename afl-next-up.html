<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NEXT GAME</title>
  <meta name="viewport" content="width=1080, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    /* Anton font */
    @font-face {
      font-family: 'Anton';
      src: url('/fonts/Anton-Regular.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    /* Lock to 1080x1920 and scale to fit */
    html, body { margin:0; padding:0; background:#000; height:100%; overflow:hidden; }
    .frame { position:relative; width:1080px; height:1920px; margin:0 auto; color:#fff; transform-origin:top left; transition: opacity 600ms ease; }
    @media (min-aspect-ratio: 9/16) { .frame { transform: scale(calc(100vh / 1920)); } }
    @media (max-aspect-ratio: 9/16) { .frame { transform: scale(calc(100vw / 1080)); } }
    body.off .frame { opacity: 0; }

    /* Diagonal background */
    .bg {
      position:absolute; inset:0;
      --home:#1a3b8d;   /* top colour */
      --away:#e63946;   /* bottom colour */
      --angle:150deg;   /* split angle */
      background: linear-gradient(var(--angle), var(--home) 50%, var(--away) 50%);
      z-index:0;
    }

    /* Header */
    header {
      position:absolute; top:40px; left:60px; right:60px; z-index:5; text-align:left;
      font-family:'Anton', sans-serif; font-size:120px; letter-spacing:2px; line-height:1;
      text-transform:uppercase; text-shadow:0 6px 18px rgba(0,0,0,.35);
    }
    header .sub { display:block; font-size:40px; font-family:Arial, sans-serif; opacity:.9; margin-top:10px; }

    /* Center content */
    .center-wrap {
      position:absolute; top:220px; bottom:200px; left:60px; right:60px; z-index:3;
      display:grid; grid-template-rows: 1fr auto 1fr auto; align-items:center; justify-items:center; gap:20px;
    }

    /* Team blocks: logos only */
    .team {
      display:grid; place-items:center;
      text-shadow:0 6px 16px rgba(0,0,0,.35);
      width:100%;
    }

    /* Nudge the home logo left, away logo right */
    #homeTeam { justify-self: start; }
    #awayTeam { justify-self: end; }

    .team .logo {
      width: 560px;   /* scaled up */
      height: 560px;  /* scaled up */
      background: rgba(255,255,255,.06);
      border-radius: 50%;
      display: grid;
      place-items: center;
      overflow: hidden;
      backdrop-filter: blur(2px);
      /* Subtle white stroke + inner glow + soft drop */
      border: 3px solid rgba(255,255,255,0.65);
      box-shadow:
        0 0 0 2px rgba(255,255,255,0.12) inset,
        0 10px 28px rgba(0,0,0,0.40);
    }
    .team .logo img {
      max-width: 90%;
      max-height: 90%;
      display: block;
    }

    /* Entrance animations */
    @keyframes slideInLeft {
      0% { transform: translateX(-120%) scale(0.9); opacity: 0; }
      60% { transform: translateX(20%) scale(1.02); opacity: 1; }
      100% { transform: translateX(0) scale(1); opacity: 1; }
    }
    @keyframes slideInRight {
      0% { transform: translateX(120%) scale(0.9); opacity: 0; }
      60% { transform: translateX(-20%) scale(1.02); opacity: 1; }
      100% { transform: translateX(0) scale(1); opacity: 1; }
    }

    /* Apply animations to each logo wrapper */
    #homeTeam .logo {
      animation: slideInLeft 900ms cubic-bezier(.2,.8,.2,1) both 100ms;
    }
    #awayTeam .logo {
      animation: slideInRight 900ms cubic-bezier(.2,.8,.2,1) both 220ms;
    }

    /* VS badge */
    .vs {
      width:220px; height:220px; border-radius:999px; display:grid; place-items:center;
      font-family:'Anton', sans-serif; font-size:120px; letter-spacing:2px;
      text-shadow:0 6px 16px rgba(0,0,0,.35); background:rgba(0,0,0,.25);
      border:3px solid rgba(255,255,255,.35); z-index:6; backdrop-filter:blur(3px);
    }

    /* Time/Date under VS */
    .meta { margin-top:10px; font-size:44px; font-weight:700; text-shadow:0 6px 16px rgba(0,0,0,.35); }

    /* Footer */
    footer {
      position:absolute; bottom:36px; left:60px; right:60px; z-index:5;
      display:flex; align-items:center; justify-content:flex-end; gap:20px;
      text-shadow:0 6px 16px rgba(0,0,0,.35);
    }
    footer .cta { font-family:'Anton', sans-serif; font-size:44px; letter-spacing:1px; text-transform:uppercase; white-space:nowrap; }
    footer img { height:70px; width:auto; display:block; object-fit:contain; filter:drop-shadow(0 6px 12px rgba(0,0,0,0.35)); }

    /* Fades (optional) */
    .fade-top, .fade-bottom { position:absolute; left:0; right:0; height:240px; z-index:1; pointer-events:none; }
    .fade-top { top:0; background:linear-gradient(to bottom, rgba(0,0,0,.35), transparent); }
    .fade-bottom { bottom:0; background:linear-gradient(to top, rgba(0,0,0,.35), transparent); }

    /* Error ribbon */
    .err { position:absolute; top:0; left:0; right:0; padding:8px 12px; background:rgba(255,50,50,.85); color:#fff;
      font:600 20px/1.2 Arial, sans-serif; z-index:999; display:none; }

    /* Respect reduced-motion */
    @media (prefers-reduced-motion: reduce) {
      #homeTeam .logo, #awayTeam .logo { animation: none !important; }
      .frame { transition: none; }
    }
  </style>
</head>

<!-- Force the Netlify function endpoint (no .js in URL) -->
<body data-endpoint="/.netlify/functions/squiggle">
  <div class="frame" id="frame">
    <div class="err" id="err"></div>
    <div class="bg" id="bg"></div>

    <header>
      NEXT GAME
      <span class="sub" id="subtitle"></span>
    </header>

    <div class="center-wrap">
      <div class="team" id="homeTeam">
        <div class="logo"><img id="homeLogo" alt="Home team logo"></div>
      </div>

      <div class="vs">VS</div>

      <div class="team" id="awayTeam">
        <div class="logo"><img id="awayLogo" alt="Away team logo"></div>
      </div>

      <div class="meta" id="meta"></div>
    </div>

    <footer>
      <div class="cta">LIVE AND LOUD AT</div>
      <img src="/images/33Degrees-clear-BG.png" alt="33 Degrees">
    </footer>

    <div class="fade-top"></div>
    <div class="fade-bottom"></div>
  </div>

  <script>
    /* ===== Config: display time (ms) before auto-off ===== */
    const DISPLAY_MS = 15000; // 15 seconds

    /* ===== Public helpers (override colours/angle if you want) ===== */
    function setColours(homeHex, awayHex) {
      const bg = document.getElementById('bg');
      if (homeHex) bg.style.setProperty('--home', homeHex);
      if (awayHex) bg.style.setProperty('--away', awayHex);
    }
    function setAngle(deg) {
      document.getElementById('bg').style.setProperty('--angle', (deg || 150) + 'deg');
    }
    setAngle(150);

    /* ===== Team assets ===== */
    const logoBase = '/afl-logos/';
    const teamLogo = {
      "Adelaide": "adelaide_crows.png",
      "Brisbane Lions": "brisbane_lions.png",
      "Carlton": "carlton.png",
      "Collingwood": "collingwood.png",
      "Essendon": "essendon.png",
      "Fremantle": "fremantle_dockers.png",
      "Geelong": "geelong_cats.png",
      "Gold Coast": "suns.png",
      "Greater Western Sydney": "giants.png",
      "Hawthorn": "hawks.png",
      "Melbourne": "melbourne.png",
      "North Melbourne": "north_melbourne.png",
      "Port Adelaide": "port_adelaide.png",
      "Richmond": "richmond.png",
      "St Kilda": "st_kilda.png",
      "Sydney": "sydney_swans.png",
      "West Coast": "west_coast.png",
      "Western Bulldogs": "western_bulldogs.png"
    };
    const teamColour = {
      "Adelaide": "#001A57",
      "Brisbane Lions": "#7C1C3A",
      "Carlton": "#001F5B",
      "Collingwood": "#000000",
      "Essendon": "#D50032",
      "Fremantle": "#2A0E54",
      "Geelong": "#0D3B66",
      "Gold Coast": "#E31837",
      "Greater Western Sydney": "#F05A28",
      "Hawthorn": "#3B1B0A",
      "Melbourne": "#0F1131",
      "North Melbourne": "#0245A3",
      "Port Adelaide": "#00B3B8",
      "Richmond": "#F6BE00",
      "St Kilda": "#D50032",
      "Sydney": "#D50032",
      "West Coast": "#003087",
      "Western Bulldogs": "#0055A4"
    };
    function getLogo(team) { const f = teamLogo[team]; return f ? logoBase + f : ''; }

    /* ===== Error ribbon ===== */
    function showErr(msg) { const el = document.getElementById('err'); el.textContent = msg; el.style.display = 'block'; }
    function hideErr(){ document.getElementById('err').style.display = 'none'; }

    /* ===== XML parsing for Squiggle (<games><anon>…</anon>) ===== */
    function getTagText(el, names) {
      for (const n of names) {
        const node = el.getElementsByTagName(n)[0];
        if (node && node.textContent) return node.textContent.trim();
      }
      return '';
    }

    function xmlToGames(xmlText) {
      const doc = new DOMParser().parseFromString(xmlText, 'text/xml');
      if (doc.getElementsByTagName('parsererror')[0]) return [];

      const gamesRoot = doc.getElementsByTagName('games')[0] || doc.documentElement;

      // Squiggle sometimes uses <game>, often <anon>
      let nodes = Array.from(gamesRoot.getElementsByTagName('game'));
      if (!nodes.length) nodes = Array.from(gamesRoot.getElementsByTagName('anon'));
      if (!nodes.length) nodes = Array.from(gamesRoot.children); // fallback

      return nodes.map(n => ({
        hteam: getTagText(n, ['hteam','home','hometeam','home_team']),
        ateam: getTagText(n, ['ateam','away','awayteam','away_team']),
        localtime: getTagText(n, ['localtime','start','date','time','localtime_utc']),
        complete: getTagText(n, ['complete']),
        id: getTagText(n, ['id'])
      }));
    }

    /* ===== Time helpers ===== */
    function parseGameStart(game) {
      let s = game.localtime || game.start || game.date || game.time || null;
      if (!s) return null;
      // Normalise "YYYY-MM-DD HH:mm:ss" -> "YYYY-MM-DDTHH:mm:ss"
      if (typeof s === 'string' && s.indexOf('T') === -1 && /^\d{4}-\d{2}-\d{2} \d{2}:/.test(s)) {
        s = s.replace(' ', 'T');
      }
      return new Date(s); // Treated as local device time (WA screen)
    }

    function isStarted(game, now) { const d = parseGameStart(game); return d ? (+d <= +now) : false; }

    function fmtMeta(game) {
      const d = parseGameStart(game); if (!d) return '';
      return new Intl.DateTimeFormat('en-AU', {
        weekday:'short', day:'2-digit', month:'short', hour:'numeric', minute:'2-digit', hour12:true
      }).format(d);
    }

    function pickNextGame(list) {
      const now = new Date();
      return list
        .filter(g => parseGameStart(g))     // must have a time
        .filter(g => !isStarted(g, now))    // not started yet
        .sort((a,b) => parseGameStart(a) - parseGameStart(b))[0] || null;
    }

    /* ===== Fetch Netlify function (expecting XML) ===== */
    async function fetchSquiggle() {
      const url = (document.body.dataset.endpoint || '/.netlify/functions/squiggle').trim();

      const res = await fetch(url, {
        method: 'GET',
        mode: 'cors',
        credentials: 'omit',
        cache: 'no-store',
        headers: { 'Accept': 'application/xml,text/xml,*/*' }
      });

      const raw = await res.text();

      if (!res.ok) {
        throw new Error(`HTTP ${res.status} ${res.statusText} — ${raw.slice(0,240)}…`);
      }

      // If JSON sneaks through, handle it
      const ct = (res.headers.get('content-type') || '').toLowerCase();
      if (ct.includes('json') || raw.trim().startsWith('{') || raw.trim().startsWith('[')) {
        try {
          const j = JSON.parse(raw);
          return Array.isArray(j) ? j : (j.games || j.data || j.items || j);
        } catch {
          throw new Error(`JSON-like response but failed to parse: ${raw.slice(0,240)}…`);
        }
      }

      const games = xmlToGames(raw);
      if (!games.length) throw new Error(`XML parsed but found no <game>/<anon> elements. First 240 chars: ${raw.slice(0,240)}…`);
      return games;
    }

    /* ===== UI bindings ===== */
    function setTeamUI(home, away) {
      const homeLogo = document.getElementById('homeLogo');
      const awayLogo = document.getElementById('awayLogo');

      const hLogo = getLogo(home), aLogo = getLogo(away);

      if (hLogo) { homeLogo.src = hLogo; homeLogo.style.visibility = 'visible'; }
      else { homeLogo.removeAttribute('src'); homeLogo.style.visibility = 'hidden'; }

      if (aLogo) { awayLogo.src = aLogo; awayLogo.style.visibility = 'visible'; }
      else { awayLogo.removeAttribute('src'); awayLogo.style.visibility = 'hidden'; }
    }

    function setSubtitle(text){ document.getElementById('subtitle').textContent = text || ''; }
    function setMeta(text){ document.getElementById('meta').textContent = text || ''; }
    function updateColoursForTeams(home, away) {
      const homeHex = teamColour[home] || '#1a3b8d';
      const awayHex = teamColour[away] || '#e63946';
      setColours(homeHex, awayHex);
    }

    /* ===== Init + auto-off ===== */
    let refreshTimer = null;
    async function init() {
      hideErr();
      try {
        const payload = await fetchSquiggle();
        const list = Array.isArray(payload) ? payload : [payload];

        // Normalise keys so downstream is simple
        const normalised = list.map(g => ({
          hteam: g.hteam || g.home || g.h || g.homeTeam || '',
          ateam: g.ateam || g.away || g.a || g.awayTeam || '',
          localtime: g.localtime || g.start || g.date || g.time || g.localtime_utc || '',
          complete: g.complete || '0',
          id: g.id || ''
        }));

        const next = pickNextGame(normalised);
        if (!next) {
          setTeamUI('TBC', 'TBC'); setSubtitle('Awaiting fixture…'); setMeta('');
          return;
        }

        const home = next.hteam, away = next.ateam;
        setTeamUI(home, away);
        setSubtitle(`${home} vs ${away}`);
        setMeta(fmtMeta(next));
        updateColoursForTeams(home, away);
      } catch (err) {
        console.error(err);
        showErr(`Error loading fixture — ${String(err.message || err).slice(0,240)}`);
        setTeamUI('TBC', 'TBC'); setSubtitle('Unable to load next fixture'); setMeta('');
      }
    }

    // Kick off
    init();

    // Optional refresh (disabled after screen hides)
    refreshTimer = setInterval(init, 1000 * 60 * 5); // every 5 mins

    // Auto-off after DISPLAY_MS
    setTimeout(() => {
      if (refreshTimer) { clearInterval(refreshTimer); refreshTimer = null; }
      document.body.classList.add('off');
      // If you want to completely remove from layout after fade:
      // setTimeout(() => (document.getElementById('frame').style.display = 'none'), 650);
    }, DISPLAY_MS);
  </script>
</body>
</html>
