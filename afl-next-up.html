<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NEXT GAME</title>
  <meta name="viewport" content="width=1080, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
  /* ... keep all your existing styles above this point ... */

  /* Team blocks now only show the logo */
  .team {
    display: flex;
    align-items: center;
    justify-content: center;
    text-shadow: 0 6px 16px rgba(0,0,0,.35);
  }

  /* Home (top) logo shifted left */
  #homeTeam {
    justify-content: flex-start;
  }

  /* Away (bottom) logo shifted right */
  #awayTeam {
    justify-content: flex-end;
  }

  .team .logo {
    width: 420px;
    height: 420px;
    background: rgba(255,255,255,.08);
    border-radius: 210px;
    display: grid;
    place-items: center;
    overflow: hidden;
    backdrop-filter: blur(2px);
    border: 2px solid rgba(255,255,255,.15);
  }

  .team .logo img {
    max-width: 90%;
    max-height: 90%;
    display: block;
  }

  /* Remove team name styling completely */
  .team .name { display: none; }
</style>

</head>

<!-- Force the Netlify function endpoint (no .js in URL) -->
<body data-endpoint="/.netlify/functions/squiggle">
  <div class="frame" id="frame">
    <div class="err" id="err"></div>
    <div class="bg" id="bg"></div>

    <header>
      NEXT GAME
      <span class="sub" id="subtitle"></span>
    </header>

    <div class="center-wrap">
      <div class="team" id="homeTeam">
        <div class="logo"><img id="homeLogo" alt="Home team logo"></div>
        <div class="name" id="homeName">HOME</div>
      </div>

      <div class="vs">VS</div>

      <div class="team" id="awayTeam">
        <div class="logo"><img id="awayLogo" alt="Away team logo"></div>
        <div class="name" id="awayName">AWAY</div>
      </div>

      <div class="meta" id="meta"></div>
    </div>

    <footer>
      <div class="cta">LIVE AND LOUD AT</div>
      <img src="/images/33Degrees-clear-BG.png" alt="33 Degrees">
    </footer>

    <div class="fade-top"></div>
    <div class="fade-bottom"></div>
  </div>

  <script>
    /* ===== Public helpers (override colours/angle if you want) ===== */
    function setColours(homeHex, awayHex) {
      const bg = document.getElementById('bg');
      if (homeHex) bg.style.setProperty('--home', homeHex);
      if (awayHex) bg.style.setProperty('--away', awayHex);
    }
    function setAngle(deg) {
      document.getElementById('bg').style.setProperty('--angle', (deg || 150) + 'deg');
    }
    setAngle(150);

    /* ===== Team assets ===== */
    const logoBase = '/afl-logos/';
    const teamLogo = {
      "Adelaide": "adelaide_crows.png",
      "Brisbane Lions": "brisbane_lions.png",
      "Carlton": "carlton.png",
      "Collingwood": "collingwood.png",
      "Essendon": "essendon.png",
      "Fremantle": "fremantle_dockers.png",
      "Geelong": "geelong_cats.png",
      "Gold Coast": "suns.png",
      "Greater Western Sydney": "giants.png",
      "Hawthorn": "hawks.png",
      "Melbourne": "melbourne.png",
      "North Melbourne": "north_melbourne.png",
      "Port Adelaide": "port_adelaide.png",
      "Richmond": "richmond.png",
      "St Kilda": "st_kilda.png",
      "Sydney": "sydney_swans.png",
      "West Coast": "west_coast.png",
      "Western Bulldogs": "western_bulldogs.png"
    };
    const teamColour = {
      "Adelaide": "#001A57",
      "Brisbane Lions": "#7C1C3A",
      "Carlton": "#001F5B",
      "Collingwood": "#000000",
      "Essendon": "#D50032",
      "Fremantle": "#2A0E54",
      "Geelong": "#0D3B66",
      "Gold Coast": "#E31837",
      "Greater Western Sydney": "#F05A28",
      "Hawthorn": "#3B1B0A",
      "Melbourne": "#0F1131",
      "North Melbourne": "#0245A3",
      "Port Adelaide": "#00B3B8",
      "Richmond": "#F6BE00",
      "St Kilda": "#D50032",
      "Sydney": "#D50032",
      "West Coast": "#003087",
      "Western Bulldogs": "#0055A4"
    };
    function getLogo(team) { const f = teamLogo[team]; return f ? logoBase + f : ''; }

    /* ===== Error ribbon ===== */
    function showErr(msg) { const el = document.getElementById('err'); el.textContent = msg; el.style.display = 'block'; }
    function hideErr(){ document.getElementById('err').style.display = 'none'; }

    /* ===== XML parsing for Squiggle (<games><anon>…</anon>) ===== */
    function getTagText(el, names) {
      for (const n of names) {
        const node = el.getElementsByTagName(n)[0];
        if (node && node.textContent) return node.textContent.trim();
      }
      return '';
    }

    function xmlToGames(xmlText) {
      const doc = new DOMParser().parseFromString(xmlText, 'text/xml');
      if (doc.getElementsByTagName('parsererror')[0]) return [];

      const gamesRoot = doc.getElementsByTagName('games')[0] || doc.documentElement;

      // Squiggle sometimes uses <game>, often <anon>
      let nodes = Array.from(gamesRoot.getElementsByTagName('game'));
      if (!nodes.length) nodes = Array.from(gamesRoot.getElementsByTagName('anon'));
      if (!nodes.length) nodes = Array.from(gamesRoot.children); // fallback

      return nodes.map(n => ({
        hteam: getTagText(n, ['hteam','home','hometeam','home_team']),
        ateam: getTagText(n, ['ateam','away','awayteam','away_team']),
        localtime: getTagText(n, ['localtime','start','date','time','localtime_utc']),
        complete: getTagText(n, ['complete']),
        id: getTagText(n, ['id'])
      }));
    }

    /* ===== Time helpers ===== */
    function parseGameStart(game) {
      let s = game.localtime || game.start || game.date || game.time || null;
      if (!s) return null;
      // Normalise "YYYY-MM-DD HH:mm:ss" -> "YYYY-MM-DDTHH:mm:ss"
      if (typeof s === 'string' && s.indexOf('T') === -1 && /^\d{4}-\d{2}-\d{2} \d{2}:/.test(s)) {
        s = s.replace(' ', 'T');
      }
      return new Date(s); // Treated as local device time (WA screen)
    }

    function isStarted(game, now) { const d = parseGameStart(game); return d ? (+d <= +now) : false; }

    function fmtMeta(game) {
      const d = parseGameStart(game); if (!d) return '';
      return new Intl.DateTimeFormat('en-AU', {
        weekday:'short', day:'2-digit', month:'short', hour:'numeric', minute:'2-digit', hour12:true
      }).format(d);
    }

    function pickNextGame(list) {
      const now = new Date();
      return list
        .filter(g => parseGameStart(g))     // must have a time
        .filter(g => !isStarted(g, now))    // not started yet
        .sort((a,b) => parseGameStart(a) - parseGameStart(b))[0] || null;
    }

    /* ===== Fetch Netlify function (expecting XML) ===== */
    async function fetchSquiggle() {
      const url = (document.body.dataset.endpoint || '/.netlify/functions/squiggle').trim();

      const res = await fetch(url, {
        method: 'GET',
        mode: 'cors',
        credentials: 'omit',
        cache: 'no-store',
        headers: { 'Accept': 'application/xml,text/xml,*/*' }
      });

      const raw = await res.text();

      if (!res.ok) {
        throw new Error(`HTTP ${res.status} ${res.statusText} — ${raw.slice(0,240)}…`);
      }

      // If JSON sneaks through, handle it
      const ct = (res.headers.get('content-type') || '').toLowerCase();
      if (ct.includes('json') || raw.trim().startsWith('{') || raw.trim().startsWith('[')) {
        try {
          const j = JSON.parse(raw);
          return Array.isArray(j) ? j : (j.games || j.data || j.items || j);
        } catch {
          throw new Error(`JSON-like response but failed to parse: ${raw.slice(0,240)}…`);
        }
      }

      const games = xmlToGames(raw);
      if (!games.length) throw new Error(`XML parsed but found no <game>/<anon> elements. First 240 chars: ${raw.slice(0,240)}…`);
      return games;
    }

    /* ===== UI bindings ===== */
    function setTeamUI(home, away) {
      document.getElementById('homeName').textContent = home || 'HOME';
      document.getElementById('awayName').textContent = away || 'AWAY';

      const homeLogo = document.getElementById('homeLogo');
      const awayLogo = document.getElementById('awayLogo');

      const hLogo = getLogo(home), aLogo = getLogo(away);

      if (hLogo) { homeLogo.src = hLogo; homeLogo.style.visibility = 'visible'; }
      else { homeLogo.removeAttribute('src'); homeLogo.style.visibility = 'hidden'; }

      if (aLogo) { awayLogo.src = aLogo; awayLogo.style.visibility = 'visible'; }
      else { awayLogo.removeAttribute('src'); awayLogo.style.visibility = 'hidden'; }
    }

    function setSubtitle(text){ document.getElementById('subtitle').textContent = text || ''; }
    function setMeta(text){ document.getElementById('meta').textContent = text || ''; }
    function updateColoursForTeams(home, away) {
      const homeHex = teamColour[home] || '#1a3b8d';
      const awayHex = teamColour[away] || '#e63946';
      setColours(homeHex, awayHex);
    }

    /* ===== Init ===== */
    async function init() {
      hideErr();
      try {
        const payload = await fetchSquiggle();
        const list = Array.isArray(payload) ? payload : [payload];

        // Normalise keys so downstream is simple
        const normalised = list.map(g => ({
          hteam: g.hteam || g.home || g.h || g.homeTeam || '',
          ateam: g.ateam || g.away || g.a || g.awayTeam || '',
          localtime: g.localtime || g.start || g.date || g.time || g.localtime_utc || '',
          complete: g.complete || '0',
          id: g.id || ''
        }));

        const next = pickNextGame(normalised);
        if (!next) {
          setTeamUI('TBC', 'TBC'); setSubtitle('Awaiting fixture…'); setMeta('');
          return;
        }

        const home = next.hteam, away = next.ateam;
        setTeamUI(home, away);
        setSubtitle(`${home} vs ${away}`);
        setMeta(fmtMeta(next));
        updateColoursForTeams(home, away);
      } catch (err) {
        console.error(err);
        showErr(`Error loading fixture — ${String(err.message || err).slice(0,240)}`);
        setTeamUI('TBC', 'TBC'); setSubtitle('Unable to load next fixture'); setMeta('');
      }
    }

    init();
    setInterval(init, 1000 * 60 * 5); // refresh every 5 mins
  </script>
</body>
</html>
